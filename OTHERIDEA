package bg.sofia.uni.fmi.mjt.server;

import bg.sofia.uni.fmi.mjt.server.repositories.InMemoryPlaylistRepository;
import bg.sofia.uni.fmi.mjt.server.repositories.InMemorySongRepository;
import bg.sofia.uni.fmi.mjt.server.repositories.InMemoryUserRepository;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SpotifyServer {
    public static final int SERVER_PORT = 4444;
    public static final String SERVER_HOST = "localhost";
    private static final String EXCEPTION_LOG_FILE = "exception-log.txt";
    private static final int THREADS_COUNT = 100;
    private static ExecutorService executorService = Executors.newFixedThreadPool(THREADS_COUNT);
    private static InMemoryUserRepository userRepository = new InMemoryUserRepository();
    private static InMemoryPlaylistRepository playlistRepository = new InMemoryPlaylistRepository();
    private static InMemorySongRepository songRepository = new InMemorySongRepository();

    static {
        try {
            PrintStream fileStream = new PrintStream(new FileOutputStream(EXCEPTION_LOG_FILE));
            System.setErr(fileStream);
        } catch (IOException e) {
            logException(e);
            throw new RuntimeException("Problem with the exception log file", e);
        }
    }

    public static void logException(Throwable t) {
        System.err.println("Exception logged: " + t.getMessage());
    }

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(THREADS_COUNT);

        Thread.currentThread().setName("Order Server Thread");

        try (ServerSocket serverSocket = new ServerSocket(SERVER_PORT)) {
            Socket clientSocket;
            while (true) {
                clientSocket = serverSocket.accept();
                SpotifyClientHandler clientHandler =
                        new SpotifyClientHandler(clientSocket, userRepository, playlistRepository, songRepository);
                executor.execute(clientHandler);
            }

        } catch (IOException e) {
            logException(e);
            throw new RuntimeException("Problem with the server socket", e);
        }
    }

    private static void handleSelectedKeys(Selector selector, ByteBuffer buffer) throws IOException {
        Set<SelectionKey> selectedKeys = selector.selectedKeys();
        Iterator<SelectionKey> keyIterator = selectedKeys.iterator();

        while (keyIterator.hasNext()) {
            SelectionKey key = keyIterator.next();
            if (key.isReadable()) {
                SocketChannel sc = (SocketChannel) key.channel();

                buffer.clear();
                int req = sc.read(buffer);
                if (req < 0) {
                    System.out.println("Client has closed the connection");
                    sc.close();
                    continue;
                }
                buffer.flip();
                sc.write(buffer);

            } else if (key.isAcceptable()) {
                ServerSocketChannel sockChannel = (ServerSocketChannel) key.channel();
                SocketChannel accept = sockChannel.accept();
                accept.configureBlocking(false);
                accept.register(selector, SelectionKey.OP_READ);
                executorService.submit(new SpotifyClientHandler(accept.socket(),
                        userRepository, playlistRepository, songRepository));
            }
            keyIterator.remove();
        }
    }
}

package bg.sofia.uni.fmi.mjt.server;

import bg.sofia.uni.fmi.mjt.server.repositories.InMemoryPlaylistRepository;
import bg.sofia.uni.fmi.mjt.server.repositories.InMemorySongRepository;
import bg.sofia.uni.fmi.mjt.server.repositories.InMemoryUserRepository;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Arrays;

import static bg.sofia.uni.fmi.mjt.server.SpotifyServer.logException;
import static bg.sofia.uni.fmi.mjt.server.command.CommandManager.processCommand;

public class SpotifyClientHandler implements Runnable {
    private final Socket clientSocket;
    private final InMemoryUserRepository userRepository;
    private final InMemoryPlaylistRepository playlistRepository;
    private final InMemorySongRepository songRepository;

    public SpotifyClientHandler(Socket clientSocket, InMemoryUserRepository userRepository,
                                InMemoryPlaylistRepository playlistRepository, InMemorySongRepository songRepository) {
        this.clientSocket = clientSocket;
        this.userRepository = userRepository;
        this.playlistRepository = playlistRepository;
        this.songRepository = songRepository;
    }

    @Override
    public void run() {
        Thread.currentThread().setName("Client Request Handler for " + clientSocket.getRemoteSocketAddress());

        try (PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
             BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) {

            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                String[] tokens = inputLine.split("\\s+|(?<=<)|(?=>)"); //TODO: fix this regex and cleanup code
                tokens = Arrays.stream(tokens)
                        .filter(token -> !(token.contains("<") || token.contains(">"))).toArray(String[]::new);
                processCommand(userRepository, playlistRepository, songRepository, out, tokens);
            }

        } catch (IOException e) {
            logException(e);
            System.err.println("Client disconnected abruptly");
        } finally {
            try {
                clientSocket.close();
            } catch (IOException e) {
                logException(e);
                System.err.println("Client failed to close connection");
            }
        }
    }

}

package bg.sofia.uni.fmi.mjt.client;

import bg.sofia.uni.fmi.mjt.server.track.TrackListener;

import javax.naming.OperationNotSupportedException;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.Line;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.SocketChannel;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

import static bg.sofia.uni.fmi.mjt.server.SpotifyServer.SERVER_HOST;
import static bg.sofia.uni.fmi.mjt.server.SpotifyServer.logException;

public class SpotifyClient implements Runnable {
    private static final int RESPONSE_STATUS_INDEX = 0;
    private static final int ENCODING_INDEX = 1;
    private static final int SAMPLE_RATE_INDEX = 2;
    private static final int SAMPLE_SIZE_IN_BITS_INDEX = 3;
    private static final int CHANNELS_INDEX = 4;
    private static final int FRAME_SIZE_INDEX = 5;
    private static final int FRAME_RATE_INDEX = 6;
    private static final int BIG_ENDIAN_INDEX = 7;
    private static final int PORT_INDEX = 8;
    private static final int SERVER_PORT = 4444;
    private boolean end = false;
    private SourceDataLine sourceDataLine = null;

    public static void main(String[] args) {
        new Thread(new SpotifyClient()).start();
    }
    public void run() {

        try (SocketChannel socketChannel = SocketChannel.open(); Scanner scanner = new Scanner(System.in);
             PrintWriter logsWriter =  new PrintWriter(Channels.newWriter(socketChannel, StandardCharsets.UTF_8), true)) {
            socketChannel.connect(new InetSocketAddress(SERVER_HOST, SERVER_PORT));

            System.out.println("Connected to the server.");
            while (!end) {
                System.out.println("Enter message: ");
                String message = scanner.nextLine();

                if ("disconnect".equals(message) || "terminate".equals(message)) {
                    end = true;
                }

                if ("stop".equalsIgnoreCase(message)) {
                    try {
                        stopSong();
                    } catch (OperationNotSupportedException e) {
                        logException(new Exception("Nothing to stop. No Song is playing", e));
                    }
                    continue;
                }

                logMessage("Sending message <" + message + "> to the server", logsWriter);
                writeToServer(message, socketChannel);

                String reply = readServerResponse(socketChannel);
                logMessage(reply, logsWriter);

                if (message.startsWith("play")) {
                    try {
                        constructSourceDataLine(reply);
                    } catch (LineUnavailableException e) {
                        logException(new Exception("Streaming failed", e));
                    }
                }
            }

            try {
                stopSong();
                logMessage("Song stopped", logsWriter);
            } catch (OperationNotSupportedException ignore) {
            } finally {
                logMessage("Ending Program", logsWriter);
            }

        } catch (IOException e) {
            System.out.println("The Server is offline");
        }
    }

    private static void logMessage(String message, PrintWriter logsWriter) {
        System.out.println(message);
        logsWriter.println(message);
    }
    private void stopSong() throws OperationNotSupportedException {
        try {
            sourceDataLine.stop();
        } catch (Exception e) {
            throw new OperationNotSupportedException("No Song is playing");
        }
    }

    private static void writeToServer(String message, SocketChannel socketChannel) {
        try {
            ByteBuffer buffer = ByteBuffer.wrap(message.getBytes());
            socketChannel.write(buffer);
        } catch (IOException e) {
            logException(new Exception("Error writing to the server", e));
        }
    }

    private static String readServerResponse(SocketChannel socketChannel) {
        try {
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            socketChannel.read(buffer);
            buffer.flip();
            byte[] bytes = new byte[buffer.remaining()];
            buffer.get(bytes);
            return new String(bytes, StandardCharsets.UTF_8);
        } catch (IOException e) {
            logException(new Exception("Error reading from the server", e));
            return "";
        }
    }

    public void constructSourceDataLine(String reply) throws LineUnavailableException {
        String[] splitReply = reply.split("\\s+");

        if (!splitReply[RESPONSE_STATUS_INDEX].equalsIgnoreCase("ok")) {
            return;
        }

        AudioFormat audioFormat = new AudioFormat(
                new AudioFormat.Encoding(splitReply[ENCODING_INDEX]),
                Float.parseFloat(splitReply[SAMPLE_RATE_INDEX]),
                Integer.parseInt(splitReply[SAMPLE_SIZE_IN_BITS_INDEX]),
                Integer.parseInt(splitReply[CHANNELS_INDEX]),
                Integer.parseInt(splitReply[FRAME_SIZE_INDEX]),
                Float.parseFloat(splitReply[FRAME_RATE_INDEX]),
                Boolean.parseBoolean(splitReply[BIG_ENDIAN_INDEX])
        );

        int streamingPort = Integer.parseInt(splitReply[PORT_INDEX]);

        Line.Info info = new DataLine.Info(SourceDataLine.class, audioFormat);
        sourceDataLine = (SourceDataLine) AudioSystem.getLine(info);
        sourceDataLine.open();
        startListener(streamingPort, sourceDataLine, this);
    }

    private void startListener(int streamingPort, SourceDataLine sourceDataLine, SpotifyClient instance) {
        new Thread(new TrackListener(streamingPort, sourceDataLine, instance), "Listener").start();
    }

    public void resetSourceDataLine() {
        sourceDataLine = null;
    }
}
